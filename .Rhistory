# Get page source with retry logic
html_result <- retry_with_backoff({
remDr$getPageSource()[[1]]
}, max_retries = 3)
if (is.null(html_result)) {
message(paste("❌ Failed to get page source for:", case_name))
return(NULL)
}
html_clean <- gsub("[\r\n\t]", "", html_result)
# Extract data pattern
pattern <- "var line1=\\[(\\[.*?\\])\\];"
matches <- stringr::str_match(html_clean, pattern)
if (is.na(matches[2])) {
message(paste("❌ Could not extract line1 for:", case_name))
return(NULL)
}
json_array <- paste0("[", matches[2], "]")
chart_data <- tryCatch({
fromJSON(json_array)
}, error = function(e) {
message(paste("❌ JSON parse error for", case_name, ":", e$message))
return(NULL)
})
if (is.null(chart_data) || nrow(chart_data) == 0) {
message(paste("❌ No chart data found for:", case_name))
return(NULL)
}
num_cols <- ncol(chart_data)
df <- tibble(
time = chart_data[, 1],
price_usd = as.numeric(chart_data[, 2]),
volume = if (num_cols >= 3) as.numeric(chart_data[, 3]) else NA_real_
) %>%
mutate(
time_clean = str_remove(time, " \\+0$"),
date = parse_date_time(time_clean, orders = "b d Y H", tz = "UTC"),
Case = case_name,
Item_Type = "Case"
) %>%
select(Case, Item_Type, date, price_usd, volume) %>%
filter(!is.na(date))
message(paste("✓ Successfully scraped data for:", case_name, "with", nrow(df), "data points"))
return(df)
}
# Improved function to scrape skin data with retry and session management
scrape_skin_chart_data <- function(skin_name, remDr, wait_base = 6, wait_var = 3) {
encoded_skin <- URLencode(skin_name)
url <- paste0("https://steamcommunity.com/market/listings/730/", encoded_skin)
message(paste("Scraping skin:", skin_name))
# Navigate with retry logic
navigate_result <- retry_with_backoff({
remDr$navigate(url)
random_delay(wait_base, wait_var)
TRUE
}, max_retries = 3)
if (!navigate_result) {
message(paste("❌ Failed to navigate to URL for:", skin_name))
return(NULL)
}
# Get page source with retry logic
html_result <- retry_with_backoff({
remDr$getPageSource()[[1]]
}, max_retries = 3)
if (is.null(html_result)) {
message(paste("❌ Failed to get page source for:", skin_name))
return(NULL)
}
html_clean <- gsub("[\r\n\t]", "", html_result)
# Extract data pattern
pattern <- "var line1=\\[(\\[.*?\\])\\];"
matches <- stringr::str_match(html_clean, pattern)
if (is.na(matches[2])) {
message(paste("❌ Could not extract line1 for:", skin_name))
return(NULL)
}
json_array <- paste0("[", matches[2], "]")
chart_data <- tryCatch({
fromJSON(json_array)
}, error = function(e) {
message(paste("❌ JSON parse error for", skin_name, ":", e$message))
return(NULL)
})
if (is.null(chart_data) || nrow(chart_data) == 0) {
message(paste("❌ No chart data found for:", skin_name))
return(NULL)
}
num_cols <- ncol(chart_data)
df <- tibble(
time = chart_data[, 1],
price_usd = as.numeric(chart_data[, 2]),
volume = if (num_cols >= 3) as.numeric(chart_data[, 3]) else NA_real_
) %>%
mutate(
time_clean = str_remove(time, " \\+0$"),
date = parse_date_time(time_clean, orders = "b d Y H", tz = "UTC"),
Skin = skin_name,
# Extract the case name from which this skin belongs
Case = names(case_skins)[sapply(case_skins, function(x) skin_name %in% x)],
Item_Type = "Skin"
) %>%
select(Case, Skin, Item_Type, date, price_usd, volume) %>%
filter(!is.na(date))
message(paste("✓ Successfully scraped data for:", skin_name, "with", nrow(df), "data points"))
return(df)
}
# Scrape data with rate limiting, session management, and checkpoint saving
scrape_with_rate_limiting <- function() {
# Flatten the case_skins list to get all skin names
all_skins <- unlist(case_skins)
# Create output directory for checkpoint files
dir.create("steam_scrape_checkpoints", showWarnings = FALSE)
# Try to load previous checkpoint if it exists
checkpoint_file <- "steam_scrape_checkpoints/scrape_checkpoint.rds"
if (file.exists(checkpoint_file)) {
checkpoint <- readRDS(checkpoint_file)
message("Resuming from checkpoint")
all_cases_data <- checkpoint$cases_data
all_skins_data <- checkpoint$skins_data
completed_cases <- checkpoint$completed_cases
completed_skins <- checkpoint$completed_skins
} else {
all_cases_data <- tibble()
all_skins_data <- tibble()
completed_cases <- character(0)
completed_skins <- character(0)
}
# Start the RSelenium server with custom profile settings
message("Starting RSelenium server...")
# Adding custom Firefox profile to make it look more like a real browser
fprof <- makeFirefoxProfile(list(
browser.sessionstore.interval = 60000,
browser.cache.disk.enable = TRUE,
browser.cache.memory.enable = TRUE,
privacy.trackingprotection.enabled = FALSE,
dom.webnotifications.enabled = FALSE,
media.volume_scale = 0,
media.autoplay.default = 0
))
rD <- rsDriver(browser = "firefox", port = 4444L, extraCapabilities = fprof, verbose = FALSE)
remDr <- rD$client
# Set window size to look more like a real browser
remDr$setWindowSize(1366, 768)
# Set a user agent
# (Note: This is simplified - a proper implementation might require more configuration)
# Main scraping logic
session_age <- 0
# 1. Scrape cases that haven't been completed yet
message("Starting case scraping...")
cases_to_scrape <- setdiff(cases, completed_cases)
for (i in seq_along(cases_to_scrape)) {
case_name <- cases_to_scrape[i]
# Check and refresh session if needed
session_result <- check_and_refresh_session(remDr, session_age)
remDr <- session_result$driver
session_age <- session_result$session_age
# Try to scrape the case data
case_data <- scrape_case_chart_data(case_name, remDr)
if (!is.null(case_data)) {
all_cases_data <- bind_rows(all_cases_data, case_data)
completed_cases <- c(completed_cases, case_name)
# Save checkpoint after each successful scrape
saveRDS(
list(
cases_data = all_cases_data,
skins_data = all_skins_data,
completed_cases = completed_cases,
completed_skins = completed_skins
),
checkpoint_file
)
message(paste("Progress:", i, "of", length(cases_to_scrape), "cases processed"))
}
# Add a longer delay between items
random_delay(10, 5)
}
message(paste("Completed scraping", length(completed_cases), "of", length(cases), "cases"))
# 2. Scrape skins that haven't been completed yet
message("Starting skin scraping...")
skins_to_scrape <- setdiff(all_skins, completed_skins)
for (i in seq_along(skins_to_scrape)) {
skin_name <- skins_to_scrape[i]
# Check and refresh session if needed
session_result <- check_and_refresh_session(remDr, session_age)
remDr <- session_result$driver
session_age <- session_result$session_age
# Try to scrape the skin data
skin_data <- scrape_skin_chart_data(skin_name, remDr)
if (!is.null(skin_data)) {
all_skins_data <- bind_rows(all_skins_data, skin_data)
completed_skins <- c(completed_skins, skin_name)
# Save checkpoint after each successful scrape
saveRDS(
list(
cases_data = all_cases_data,
skins_data = all_skins_data,
completed_cases = completed_cases,
completed_skins = completed_skins
),
checkpoint_file
)
message(paste("Progress:", i, "of", length(skins_to_scrape), "skins processed"))
}
# Add a longer delay between items
random_delay(10, 5)
}
message(paste("Completed scraping", length(completed_skins), "of", length(all_skins), "skins"))
# Stop RSelenium
remDr$close()
rD$server$stop()
return(list(cases_data = all_cases_data, skins_data = all_skins_data))
}
# Run the improved scraping function
scrape_results <- scrape_with_rate_limiting()
library(RSelenium)
library(jsonlite)
library(stringr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(tidyquant)
library(readr)
cases <- c(
"Chroma Case", "Chroma 2 Case", "Gamma Case","Glove Case","Dreams & Nightmares Case"
)
case_skins <- list(
"Chroma Case" = c(
"Glock-18 | Catacombs (Minimal Wear)",           # pistol
"AK-47 | Cartel (Minimal Wear)",                 # rifle
"AWP | Man-o'-war (Minimal Wear)"                # AWP
),
"Chroma 2 Case" = c(
"USP-S | Torque (Minimal Wear)",                 # pistol
"M4A1-S | Hyper Beast (Minimal Wear)",           # rifle
"AWP | Worm God (Minimal Wear)"                  # AWP
),
"Gamma Case" = c(
"Glock-18 | Wasteland Rebel (Minimal Wear)",     # pistol
"M4A4 | Desolate Space (Minimal Wear)",          # rifle
"AWP | Phobos (Minimal Wear)"                    # AWP-preferred random
),
"Glove Case" = c(
"USP-S | Cyrex (Minimal Wear)",                  # pistol
"M4A4 | Buzz Kill (Minimal Wear)",               # rifle
"P90 | Shallow Grave (Minimal Wear)"             # random
),
"Dreams & Nightmares Case" = c(
"USP-S | Ticket to Hell (Minimal Wear)",         # pistol
"AK-47 | Nightwish (Minimal Wear)",              # rifle
"MP9 | Starlight Protector (Minimal Wear)"       # random
)
)
# Optinal Additional Cases
casesfinal <- c(
"Chroma Case", "Chroma 2 Case", "Falchion Case", "Shadow Case",
"Revolver Case", "Operation Wildfire Case", "Chroma 3 Case",
"Gamma Case", "Gamma 2 Case", "Glove Case", "Spectrum Case",
"Operation Hydra Case", "Spectrum 2 Case", "Clutch Case",
"Horizon Case", "Danger Zone Case", "Prisma Case", "CS20 Case",
"Shattered Web Case", "Prisma 2 Case", "Fracture Case",
"Operation Broken Fang Case", "Snakebite Case",
"Operation Riptide Case", "Dreams & Nightmares Case",
"Recoil Case", "Revolution Case", "Kilowatt Case", "Gallery Case"
)
library(readr)
url_skins <- "https://raw.githubusercontent.com/AndrewPettifor25/FIN_450_Steam_Final/refs/heads/main/steam_skins_raw.csv?token=GHSAT0AAAAAAC76LQ4MJRCAELCMZQHGZUFKZ7UNG6A"
steam_skins_raw <- read_csv(url_skins)
library(RSelenium)
library(jsonlite)
library(stringr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(tidyquant)
library(readr)
cases <- c(
"Chroma Case", "Chroma 2 Case", "Gamma Case","Glove Case","Dreams & Nightmares Case"
)
case_skins <- list(
"Chroma Case" = c(
"Glock-18 | Catacombs (Minimal Wear)",           # pistol
"AK-47 | Cartel (Minimal Wear)",                 # rifle
"AWP | Man-o'-war (Minimal Wear)"                # AWP
),
"Chroma 2 Case" = c(
"USP-S | Torque (Minimal Wear)",                 # pistol
"M4A1-S | Hyper Beast (Minimal Wear)",           # rifle
"AWP | Worm God (Minimal Wear)"                  # AWP
),
"Gamma Case" = c(
"Glock-18 | Wasteland Rebel (Minimal Wear)",     # pistol
"M4A4 | Desolate Space (Minimal Wear)",          # rifle
"AWP | Phobos (Minimal Wear)"                    # AWP-preferred random
),
"Glove Case" = c(
"USP-S | Cyrex (Minimal Wear)",                  # pistol
"M4A4 | Buzz Kill (Minimal Wear)",               # rifle
"P90 | Shallow Grave (Minimal Wear)"             # random
),
"Dreams & Nightmares Case" = c(
"USP-S | Ticket to Hell (Minimal Wear)",         # pistol
"AK-47 | Nightwish (Minimal Wear)",              # rifle
"MP9 | Starlight Protector (Minimal Wear)"       # random
)
)
# Optinal Additional Cases
casesfinal <- c(
"Chroma Case", "Chroma 2 Case", "Falchion Case", "Shadow Case",
"Revolver Case", "Operation Wildfire Case", "Chroma 3 Case",
"Gamma Case", "Gamma 2 Case", "Glove Case", "Spectrum Case",
"Operation Hydra Case", "Spectrum 2 Case", "Clutch Case",
"Horizon Case", "Danger Zone Case", "Prisma Case", "CS20 Case",
"Shattered Web Case", "Prisma 2 Case", "Fracture Case",
"Operation Broken Fang Case", "Snakebite Case",
"Operation Riptide Case", "Dreams & Nightmares Case",
"Recoil Case", "Revolution Case", "Kilowatt Case", "Gallery Case"
)
library(readr)
url_skins <- "https://raw.githubusercontent.com/AndrewPettifor25/FIN_450_Steam_Final/refs/heads/main/steam_skins_raw.csv"
all_skins_data <- read_csv(url_skins)
url_cases <- "https://raw.githubusercontent.com/AndrewPettifor25/FIN_450_Steam_Final/refs/heads/main/steam_cases_raw.csv"
all_cases_data <- read_csv(url_cases)
# Combine the case and skin data
# Note: We need to modify the skin data to match the structure before combining
all_skins_data_for_combine <- all_skins_data %>%
rename(Item = Skin) %>%
select(Case, Item, Item_Type, date, price_usd, volume)
all_cases_data_for_combine <- all_cases_data %>%
mutate(Item = Case) %>%
select(Case, Item, Item_Type, date, price_usd, volume)
# Combine both datasets
all_items_data <- bind_rows(all_cases_data_for_combine, all_skins_data_for_combine)
# Data Refining for all items
all_items_data_clean <- all_items_data %>%
mutate(date = as.POSIXct(date, tz = "UTC"))
# Daily history for all items
daily_item_closes <- all_items_data_clean %>%
mutate(
hour = hour(date),
day = as.Date(date)
) %>%
filter(hour == 1) %>%  # Keep only rows with time == 1:00
group_by(Case, Item, Item_Type, day) %>%  # In case multiple entries at 1:00
slice_max(order_by = date, n = 1) %>%
ungroup() %>%
select(Case, Item, Item_Type, date, price_usd, volume) %>%
arrange(Case, Item, date)
# Past month data for all items
past_month_items <- all_items_data_clean %>%
filter(date >= Sys.Date() - months(1)) %>%
group_by(Case, Item, Item_Type) %>%
arrange(date) %>%
slice(-1) %>%  # removes the first row of each group
ungroup()
#Exchange Rates TidyQuant Ticker: "CAD=X"
fx_usdcad <- tq_get("CAD=X", get = "stock.prices", from = "2010-01-01")
fx_usdcad_clean <- fx_usdcad %>%
select(date, fx_rate = close)
fx_usdcad_filled <- fx_usdcad_clean %>%
complete(date = seq.Date(min(date), max(date), by = "day")) %>%
fill(fx_rate, .direction = "down")
# Convert to CAD
CAD_Converted_Items <- all_items_data_clean %>%
mutate(date_only = as.Date(date)) %>%
left_join(fx_usdcad_filled, by = c("date_only" = "date")) %>%
mutate(price_cad = price_usd * fx_rate) %>%
drop_na()
CAD_Selected_Items <- CAD_Converted_Items %>%
select(Case, Item, Item_Type, date, price_cad, volume)
# Daily history (CAD) for all items
Daily_CAD_Items <- CAD_Selected_Items %>%
mutate(
hour = hour(date),
day = as.Date(date)
) %>%
filter(hour == 1) %>%  # Keep only rows with time == 1:00
group_by(Case, Item, Item_Type, day) %>%  # In case multiple entries at 1:00
slice_max(order_by = date, n = 1) %>%
ungroup() %>%
select(Case, Item, Item_Type, date, price_cad, volume) %>%
arrange(Case, Item, date)
# Past month data (CAD) for all items
Month_CAD_Items <- CAD_Selected_Items %>%
filter(date >= Sys.Date() - months(1)) %>%
group_by(Case, Item, Item_Type) %>%
arrange(date) %>%
slice(-1) %>%  # removes the first row of each group
ungroup()
# Example visualization code - comparing cases and their skins
# For each case in case_skins, plot the case price and its skin prices
plot_case_and_skins <- function(case_name) {
case_data <- Month_CAD_Items %>%
filter(Case == case_name)
ggplot(case_data, aes(x = date, y = price_cad, color = Item, linetype = Item_Type)) +
geom_line() +
labs(title = paste("Price Comparison:", case_name, "and its Skins (CAD)"),
x = "Date",
y = "Price (CAD)") +
theme_minimal() +
theme(legend.position = "right")
}
# Save separate dataframes for cases and skins
cases_data <- all_items_data_clean %>% filter(Item_Type == "Case")
skins_data <- all_items_data_clean %>% filter(Item_Type == "Skin")
# Write a function to run the plots for each case in case_skins
case_plots <- lapply(names(case_skins), plot_case_and_skins)
library(RSelenium)
library(jsonlite)
library(stringr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(tidyquant)
library(readr)
library(plotly)
library(RSelenium)
library(jsonlite)
library(stringr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(tidyquant)
library(readr)
library(plotly)
# Function to create interactive plotly graph for each case and its skins
plot_case_and_skins_plotly <- function(case_name) {
# Filter data for the specific case and its skins
case_data <- Month_CAD_Items %>%
filter(Case == case_name)
# Create plotly graph
p <- plot_ly() %>%
layout(
title = paste("Price Comparison:", case_name, "and its Skins (CAD)"),
xaxis = list(title = "Date"),
yaxis = list(title = "Price (CAD)"),
hovermode = "closest"
)
# Add traces for each item
unique_items <- unique(case_data$Item)
for (item in unique_items) {
item_data <- case_data %>% filter(Item == item)
item_type <- unique(item_data$Item_Type)[1]
# Different line styles for cases vs skins
line_dash <- if(item_type == "Case") "solid" else "dash"
p <- p %>% add_trace(
data = item_data,
x = ~date,
y = ~price_cad,
type = 'scatter',
mode = 'lines',
name = item,
line = list(dash = line_dash),
hoverinfo = "text",
text = ~paste(
"Item: ", Item, "<br>",
"Price (CAD): $", round(price_cad, 2), "<br>",
"Date: ", format(date, "%Y-%m-%d"), "<br>",
"Volume: ", volume
)
)
}
return(p)
}
# Create plots for each case in case_skins
case_plots_plotly <- list()
for (case_name in names(case_skins)) {
case_plots_plotly[[case_name]] <- plot_case_and_skins_plotly(case_name)
}
# Create a plotly graph comparing only the cases
cases_comparison_plotly <- function() {
# Filter data for only cases
cases_data <- Month_CAD_Items %>%
filter(Item_Type == "Case" & Case %in% names(case_skins))
# Create plotly graph
p <- plot_ly() %>%
layout(
title = "Price Comparison of Cases (CAD)",
xaxis = list(title = "Date"),
yaxis = list(title = "Price (CAD)"),
hovermode = "closest"
)
# Add traces for each case
unique_cases <- unique(cases_data$Case)
for (case_name in unique_cases) {
case_data <- cases_data %>% filter(Case == case_name)
p <- p %>% add_trace(
data = case_data,
x = ~date,
y = ~price_cad,
type = 'scatter',
mode = 'lines',
name = case_name,
hoverinfo = "text",
text = ~paste(
"Case: ", Case, "<br>",
"Price (CAD): $", round(price_cad, 2), "<br>",
"Date: ", format(date, "%Y-%m-%d"), "<br>",
"Volume: ", volume
)
)
}
return(p)
}
# Create the cases comparison plot
cases_comparison <- cases_comparison_plotly()
